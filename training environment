import React, { useState, useCallback, useMemo, useRef, useEffect } from 'react';
import { Card, CardHeader, CardTitle, CardContent } from '@/components/ui/card';
import { Brain, Trophy, Users, LineChart, Star, Target, AlertCircle, CheckCircle2, Loader, Book, Map } from 'lucide-react';

// Constants
const CHALLENGE_TYPES = {
  PATTERN: 'pattern',
  OPTIMIZATION: 'optimization'
} as const;

const PATTERN_TYPES = {
  ARITHMETIC: 'arithmetic',
  GEOMETRIC: 'geometric',
  QUADRATIC: 'quadratic',
  EXPONENTIAL: 'exponential'
} as const;

// Constants for learning tracks
const LEARNING_TRACKS = {
  PATTERN_RECOGNITION: 'PATTERN_RECOGNITION'
};

// Learning Path Class for managing user's learning journey
class LearningPath {
  constructor(track) {
    this.track = track;
    this.level = 1;
    this.experience = 0;
    this.challenges = [];
    this.completedChallenges = [];
    this.patternPerformance = {};
  }

  updateProgress(result) {
    this.experience += result.score;
    this.completedChallenges.push({
      ...result,
      timestamp: Date.now(),
      pattern: result.pattern,
      success: result.success,
      score: result.score
    });

    // Update pattern performance
    this.patternPerformance[result.pattern.type] = this.patternPerformance[result.pattern.type] || { success: 0, total: 0 };
    this.patternPerformance[result.pattern.type].total++;
    if (result.success) this.patternPerformance[result.pattern.type].success++;

    // Level up logic
    const levelThreshold = this.level * 1000;
    if (this.experience >= levelThreshold) {
      this.level++;
      this.experience -= levelThreshold;
    }
  }

  getNextChallenge() {
    // Generate a new challenge
    const sequence = Array.from({ length: 5 }, (_, i) => i * 2 + Math.random());
    const nextNumber = sequence[sequence.length - 1] * 2;
    
    return {
      type: CHALLENGE_TYPES.PATTERN,
      data: {
        sequence,
        nextNumber,
        pattern: { type: PATTERN_TYPES.ARITHMETIC }
      },
      startTime: Date.now()
    };
  }

  getProgressReport() {
    const successRate = this.completedChallenges.filter(c => c.success).length / (this.completedChallenges.length || 1);
    return {
      currentLevel: `Level ${this.level}`,
      experiencePoints: this.experience,
      levelProgress: this.experience / (this.level * 1000),
      successRate,
      challengesCompleted: this.completedChallenges.length,
      recentHistory: this.completedChallenges.slice(-5),
      patternPerformance: this.patternPerformance,
      recommendations: this.getRecommendations()
    };
  }

  getRecommendations() {
    return Object.entries(this.patternPerformance)
      .filter(([_, stats]) => stats.success / stats.total < 0.7)
      .map(([pattern]) => `Improve your skills in ${pattern} patterns`);
  }
}

// ML System
const createMLSystem = () => {
  // Cache for expensive computations
  const computationCache = new Map();
  
  // Clear cache entries older than 5 minutes
  setInterval(() => {
    const now = Date.now();
    for (const [key, { timestamp }] of computationCache) {
      if (now - timestamp > 300000) {
        computationCache.delete(key);
      }
    }
  }, 60000);

  return {
    memory: {
      patterns: [],
      weights: Object.fromEntries(Object.values(PATTERN_TYPES).map(type => [type, 1.0])),
      recentResults: [],
      confidenceHistory: []
    },

    /**
     * Extracts features from a number sequence
     * @throws {Error} If sequence is invalid
     */
    extractFeatures(sequence) {
      // Input validation
      if (!Array.isArray(sequence) || sequence.length < 3) {
        throw new Error('Sequence must contain at least 3 numbers');
      }
      if (!sequence.every(n => typeof n === 'number' && Number.isFinite(n))) {
        throw new Error('Sequence must contain only valid numbers');
      }

      const cacheKey = sequence.join(',');
      const cached = computationCache.get(cacheKey);
      if (cached) return cached.features;

      const features = {};
      try {
        // Statistical features
        features.mean = sequence.reduce((a, b) => a + b, 0) / sequence.length;
        features.variance = sequence.reduce((a, b) => 
          a + Math.pow(b - features.mean, 2), 0) / sequence.length;

        // Pattern detection
        const differences = sequence.slice(1).map((n, i) => n - sequence[i]);
        features.diffMean = differences.reduce((a, b) => a + b, 0) / differences.length;
        
        const tolerance = 0.0001;
        features.isArithmetic = differences.every(d => Math.abs(d - differences[0]) < tolerance);
        features.isGeometric = sequence.slice(1).every((n, i) => 
          Math.abs(n / sequence[i] - sequence[1] / sequence[0]) < tolerance
        );

        computationCache.set(cacheKey, { features, timestamp: Date.now() });
        return features;
      } catch (error) {
        throw new Error(`Feature extraction failed: ${error.message}`);
      }
    },

    /**
     * Predicts pattern and next value
     * @throws {Error} If prediction fails
     */
    predict(sequence) {
      try {
        const features = this.extractFeatures(sequence);
        const scores = {};

        // Calculate confidence scores
        Object.entries(this.memory.weights).forEach(([type, weight]) => {
          let baseConfidence = 0.5;
          
          // Adjust confidence based on pattern indicators
          if (features.isArithmetic && type === PATTERN_TYPES.ARITHMETIC) {
            baseConfidence = 0.9;
          } else if (features.isGeometric && type === PATTERN_TYPES.GEOMETRIC) {
            baseConfidence = 0.9;
          }

          // Apply historical performance weighting
          const successRate = this.getSuccessRate(type);
          scores[type] = {
            confidence: Math.min(1, baseConfidence * weight * (0.7 + 0.3 * successRate)),
            weight
          };
        });

        // Find best prediction
        const bestPrediction = Object.entries(scores)
          .reduce((best, [type, data]) => 
            data.confidence > best.confidence ? { type, confidence: data.confidence } : best,
            { type: 'unknown', confidence: 0 }
          );

        this.updateConfidenceHistory(bestPrediction.confidence);
        return bestPrediction;
      } catch (error) {
        console.error('Prediction error:', error);
        throw error;
      }
    },

    /**
     * Updates system with learning from results
     * @throws {Error} If learning fails
     */
    learn(sequence, pattern, success) {
      try {
        const features = this.extractFeatures(sequence);
        
        // Store pattern
        this.memory.patterns.push({
          features,
          pattern,
          success,
          timestamp: Date.now()
        });

        // Adaptive learning rate
        const recentSuccess = this.memory.recentResults.slice(-5)
          .filter(Boolean).length / 5;
        const learningRate = 0.1 * (1 + (1 - recentSuccess));

        // Update weights
        if (success) {
          this.memory.weights[pattern.type] += learningRate;
          if (features.isArithmetic) {
            this.memory.weights[PATTERN_TYPES.ARITHMETIC] += learningRate * 0.5;
          }
          if (features.isGeometric) {
            this.memory.weights[PATTERN_TYPES.GEOMETRIC] += learningRate * 0.5;
          }
        } else {
          this.memory.weights[pattern.type] = Math.max(0.1,
            this.memory.weights[pattern.type] - learningRate * 0.5
          );
        }

        // Normalize weights
        const total = Object.values(this.memory.weights).reduce((a, b) => a + b, 0);
        Object.keys(this.memory.weights).forEach(key => {
          this.memory.weights[key] /= total;
        });

        // Update history
        this.memory.recentResults.push(success);
        if (this.memory.recentResults.length > 10) {
          this.memory.recentResults.shift();
        }
      } catch (error) {
        console.error('Learning error:', error);
        throw error;
      }
    },

    /**
     * Calculates success rate for pattern type
     * @private
     */
    getSuccessRate(patternType) {
      const patterns = this.memory.patterns.filter(p => p.pattern.type === patternType);
      if (patterns.length === 0) return 0.5;
      return patterns.filter(p => p.success).length / patterns.length;
    },

    /**
     * Updates confidence history
     * @private
     */
    updateConfidenceHistory(confidence) {
      this.memory.confidenceHistory.push({
        confidence: Math.max(0, Math.min(1, confidence)),
        timestamp: Date.now()
      });
      if (this.memory.confidenceHistory.length > 20) {
        this.memory.confidenceHistory.shift();
      }
    },

    /**
     * Cleans up resources
     */
    cleanup() {
      computationCache.clear();
    }
  };
};

/**
 * Custom hook for managing ML system
 */
const useMLSystem = () => {
  const mlSystemRef = useRef(null);
  
  if (!mlSystemRef.current) {
    mlSystemRef.current = createMLSystem();
  }

  // Memoize system status
  const systemStatus = useMemo(() => ({
    weights: mlSystemRef.current.memory.weights,
    recentResults: mlSystemRef.current.memory.recentResults,
    successRate: mlSystemRef.current.memory.recentResults.filter(Boolean).length / 
                Math.max(1, mlSystemRef.current.memory.recentResults.length),
    confidenceHistory: mlSystemRef.current.memory.confidenceHistory
  }), [mlSystemRef.current.memory.recentResults.length]);

  // Cleanup on unmount
  useEffect(() => () => mlSystemRef.current.cleanup(), []);

  return {
    mlSystem: mlSystemRef.current,
    systemStatus
  };
};

/**
 * Custom hook for managing challenges
 */
const useChallenge = (mlSystem, onComplete) => {
  const [state, setState] = useState({
    currentChallenge: null,
    userAnswer: '',
    feedback: null,
    attemptCount: 0,
    isAISolving: false,
    aiThoughts: []
  });

  const generateNewChallenge = useCallback(() => {
    try {
      const sequence = Array.from({ length: 5 }, (_, i) => i * 2 + Math.random());
      const nextNumber = sequence[sequence.length - 1] * 2;
      
      setState(prev => ({
        ...prev,
        currentChallenge: {
          type: CHALLENGE_TYPES.PATTERN,
          data: {
            sequence,
            nextNumber,
            pattern: { type: PATTERN_TYPES.ARITHMETIC }
          },
          startTime: Date.now()
        },
        userAnswer: '',
        feedback: null,
        attemptCount: 0,
        aiThoughts: []
      }));
    } catch (error) {
      setState(prev => ({
        ...prev,
        feedback: {
          status: 'error',
          message: 'Failed to generate challenge: ' + error.message
        }
      }));
    }
  }, []);

  const handleAISolve = useCallback(async () => {
    if (!state.currentChallenge || state.isAISolving) return;

    setState(prev => ({ ...prev, isAISolving: true, aiThoughts: [] }));

    try {
      const addThought = (thought) => {
        setState(prev => ({
          ...prev,
          aiThoughts: [...prev.aiThoughts, thought]
        }));
      };

      addThought("Analyzing sequence pattern...");
      await new Promise(resolve => setTimeout(resolve, 1000));

      const prediction = mlSystem.predict(state.currentChallenge.data.sequence);
      addThought(`Detected ${prediction.type} pattern with ${(prediction.confidence * 100).toFixed(1)}% confidence`);
      await new Promise(resolve => setTimeout(resolve, 1000));

      const nextValue = state.currentChallenge.data.sequence[
        state.currentChallenge.data.sequence.length - 1
      ] * 2;
      addThought(`Predicting next value: ${nextValue.toFixed(2)}`);

      setState(prev => ({
        ...prev,
        userAnswer: nextValue.toFixed(2),
        isAISolving: false
      }));
    } catch (error) {
      setState(prev => ({
        ...prev,
        isAISolving: false,
        feedback: {
          status: 'error',
          message: 'AI analysis failed: ' + error.message
        }
      }));
    }
  }, [state.currentChallenge, state.isAISolving, mlSystem]);

  const submitAnswer = useCallback(() => {
    if (!state.currentChallenge) return;

    try {
      const numAnswer = Number(state.userAnswer);
      if (!Number.isFinite(numAnswer)) {
        throw new Error('Please enter a valid number');
      }

      const isCorrect = Math.abs(numAnswer - state.currentChallenge.data.nextNumber) < 0.001;
      
      mlSystem.learn(
        state.currentChallenge.data.sequence,
        state.currentChallenge.data.pattern,
        isCorrect
      );

      const timeTaken = (Date.now() - state.currentChallenge.startTime) / 1000;
      const newAttemptCount = state.attemptCount + 1;

      setState(prev => ({
        ...prev,
        attemptCount: newAttemptCount,
        feedback: isCorrect ? {
          status: 'success',
          message: `Correct! Score: ${Math.max(0, 100 - (newAttemptCount - 1) * 20 - timeTaken / 10).toFixed(1)}`,
          score: Math.max(0, 100 - (newAttemptCount - 1) * 20 - timeTaken / 10)
        } : {
          status: 'error',
          message: 'Not quite right. Try again!'
        }
      }));

      if (isCorrect) {
        onComplete?.(Math.max(0, 100 - (newAttemptCount - 1) * 20 - timeTaken / 10));
      }
    } catch (error) {
      setState(prev => ({
        ...prev,
        feedback: {
          status: 'error',
          message: error.message
        }
      }));
    }
  }, [state.currentChallenge, state.userAnswer, state.attemptCount, mlSystem, onComplete]);

  return {
    ...state,
    setUserAnswer: (answer) => setState(prev => ({ ...prev, userAnswer: answer })),
    generateNewChallenge,
    handleAISolve,
    submitAnswer
  };
};

/**
 * Performance Metrics Component for visualization
 */
const PerformanceMetrics = ({ data }) => {
  const chartData = useMemo(() => ({
    labels: data.map(d => new Date(d.timestamp).toLocaleDateString()),
    datasets: [{
      label: 'Score',
      data: data.map(d => d.score),
      borderColor: 'rgb(59, 130, 246)',
      tension: 0.1
    }]
  }), [data]);

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <LineChart className="w-6 h-6" aria-hidden="true" />
          Performance Trends
        </CardTitle>
      </CardHeader>
      <CardContent>
        <div className="h-64 relative">
          {/* Placeholder for chart visualization */}
          <div className="absolute inset-0 flex items-center justify-center text-gray-500">
            Performance visualization would go here
          </div>
        </div>
      </CardContent>
    </Card>
  );
};

/**
 * Progress Details Component
 */
const ProgressDetails = ({ report }) => (
  <Card>
    <CardHeader>
      <CardTitle className="flex items-center gap-2">
        <LineChart className="w-6 h-6" aria-hidden="true" />
        Detailed Progress
      </CardTitle>
    </CardHeader>
    <CardContent className="space-y-6">
      {/* Experience Progress */}
      <div>
        <h3 className="text-sm font-medium text-gray-600 mb-2">Experience Growth</h3>
        <div className="h-32 bg-gray-50 rounded-lg p-4">
          {/* Add a chart here showing XP over time */}
        </div>
      </div>

      {/* Recent History */}
      <div>
        <h3 className="text-sm font-medium text-gray-600 mb-2">Recent Challenges</h3>
        <div className="space-y-2">
          {report.recentHistory.map((challenge, i) => (
            <div
              key={i}
              className="flex items-center justify-between p-2 bg-gray-50 rounded"
            >
              <div className="flex items-center gap-3">
                {challenge.success ? (
                  <Star className="w-5 h-5 text-yellow-500" aria-hidden="true" />
                ) : (
                  <Users className="w-5 h-5 text-red-500" aria-hidden="true" />
                )}
                <div>
                  <div className="font-medium capitalize">{challenge.pattern.type} Pattern</div>
                  <div className="text-sm text-gray-500">
                    {new Date(challenge.timestamp).toLocaleDateString()}
                  </div>
                </div>
              </div>
              <div className="text-right">
                <div className="font-medium">{challenge.score} XP</div>
                <div className="text-sm text-gray-500">
                  {challenge.success ? 'Success' : 'Failed'}
                </div>
              </div>
            </div>
          ))}
        </div>
      </div>

      {/* Performance Metrics */}
      <div className="grid grid-cols-2 gap-4">
        <div className="p-4 bg-gray-50 rounded-lg">
          <div className="text-sm text-gray-500">Current Level</div>
          <div className="text-xl font-bold mt-1 capitalize">{report.currentLevel}</div>
          <div className="mt-2 h-2 bg-gray-200 rounded-full overflow-hidden">
            <div
              className="h-full bg-blue-500"
              style={{ width: `${report.levelProgress * 100}%` }}
              role="progressbar"
              aria-valuenow={report.levelProgress * 100}
              aria-valuemin={0}
              aria-valuemax={100}
            />
          </div>
        </div>
        <div className="p-4 bg-gray-50 rounded-lg">
          <div className="text-sm text-gray-500">Success Rate</div>
          <div className="text-xl font-bold mt-1">
            {(report.successRate * 100).toFixed(1)}%
          </div>
          <div className="mt-2 h-2 bg-gray-200 rounded-full overflow-hidden">
            <div
              className="h-full bg-green-500"
              style={{ width: `${report.successRate * 100}%` }}
              role="progressbar"
              aria-valuenow={report.successRate * 100}
              aria-valuemin={0}
              aria-valuemax={100}
            />
          </div>
        </div>
      </div>

      {/* Pattern Performance */}
      <div>
        <h3 className="text-sm font-medium text-gray-600 mb-2">Pattern Performance</h3>
        <div className="grid gap-2">
          {Object.entries(report.patternPerformance || {}).map(([pattern, stats]) => (
            <div key={pattern} className="p-3 bg-gray-50 rounded">
              <div className="flex justify-between items-center mb-1">
                <span className="font-medium capitalize">{pattern}</span>
                <span className="text-sm text-gray-500">
                  {((stats.success / stats.total) * 100).toFixed(1)}% Success
                </span>
              </div>
              <div className="h-2 bg-gray-200 rounded-full overflow-hidden">
                <div
                  className="h-full bg-blue-500"
                  style={{ width: `${(stats.success / stats.total) * 100}%` }}
                  role="progressbar"
                  aria-valuenow={(stats.success / stats.total) * 100}
                  aria-valuemin={0}
                  aria-valuemax={100}
                />
              </div>
            </div>
          ))}
        </div>
      </div>
    </CardContent>
  </Card>
);

/**
 * Challenge Engine Component
 */
const ChallengeEngine = ({ challenge, onComplete }) => {
  const { mlSystem, systemStatus } = useMLSystem();
  const {
    currentChallenge,
    userAnswer,
    setUserAnswer,
    feedback,
    isAISolving,
    aiThoughts,
    handleAISolve,
    submitAnswer
  } = useChallenge(mlSystem,
